use axum::{
    extract::State,
    http::StatusCode,
    response::Json,
    routing::post,
    Router,
};
use serde::{Deserialize, Serialize};
use crate::storage::DbPool;

// 注册请求体（前端提交数据）
#[derive(Deserialize)]
pub struct RegisterRequest {
    pub username: String,
    pub email: String,
    pub password: String, // 明文密码（后端哈希存储）
}

// 注册响应体（返回给前端）
#[derive(Serialize)]
pub struct RegisterResponse {
    pub success: bool,
    pub message: String,
    pub user_id: Option<String>, // 成功时返回用户ID
}

// 注册处理器（核心API逻辑）
pub async fn register_handler(
    State(pool): State<DbPool>, // 注入数据库连接池
    Json(req): Json<RegisterRequest>, // 解析JSON请求体
) -> Result<Json<RegisterResponse>, AppError> {
    // 调用存储层注册用户
    let user = pool.register_user(&req.username, &req.email, &req.password)
        .map_err(|e| match e {
            rusqlite::Error::QueryReturnedNoRows => 
                AppError::UserExists("用户名或邮箱已被注册".into()),
            _ => AppError::Database(e.to_string()),
        })?;

    // 返回成功响应
    Ok(Json(RegisterResponse {
        success: true,
        message: "注册成功".into(),
        user_id: Some(user.id),
    }))
}

// 导出路由
pub fn register_routes() -> Router<DbPool> {
    Router::new()
        .route("/register", post(register_handler))
}